import sqlalchemy as sq
from sqlalchemy.orm import sessionmaker, joinedload, subqueryload
import database.models as models 
import pandas as pd
from sqlalchemy import or_, func

from sqlalchemy.exc import SQLAlchemyError
from utils.constants import DEGFilter
import re

class DB():

    # DATABASE_NAME = "test_db.sqlite"
    DATABASE_NAME = "database/data/all_xerophyta_species_db.sqlite"
    def __init__(self) -> None:
        
        self.engine = sq.create_engine(f"sqlite:///{self.DATABASE_NAME}", echo = False)
        self.conn = self.engine.connect()

        Session = sessionmaker(bind=self.engine)
        self.session = Session()

    def add_species(self, name):
        species = self.session.query(models.Species).filter_by(name=name).first()
        if not species:
            species = models.Species(name=name)
            self.session.add(species)
            self.session.commit()
        return species
    
    def add_genes_from_fasta(self, species_id, gene_name, coding_seq):
        gene = self.session.query(models.Gene).filter_by(gene_name=gene_name).first()
        if not gene:
            gene = models.Gene(gene_name=gene_name, 
                               species_id=species_id, 
                               coding_sequence=coding_seq)
            self.session.add(gene)
            self.session.commit()

        return gene

    def add_a_thaliana_gene_mappings(self, mapping_df):
        """Add A. thaliana gene locus and common name mappings to the Arabidopsis Homologue table.


        Args:
            mapping_df: dataframe containing the mapping data in format [Gene name, At Locus ID, Wiki gene description] 
                        e.g Xele.ptg000001l.104,AT5G47390,myb-like transcription factor family protein
        """
        required_columns = ["Gene name","At Locus ID","Wiki gene description"]
        if not all(col in mapping_df.columns for col in required_columns):
            raise ValueError(f"Mapping dataframe must contain columns: {required_columns}")
        
        i = 0
        for  _, row in mapping_df.iterrows():
            gene_name = row['Gene name']
            locus = row['At Locus ID']
            common_name = row['Wiki gene description']
            
            # 1. Find the existing Gene
            gene = self.session.query(models.Gene).filter_by(gene_name=gene_name).first()
            if not gene:
                # If you have missing genes, handle it or skip
                print(f"No gene found for {gene_name}, skipping.")
                continue
            
            # 2. See if there's an existing ArabidopsisHomologue with this locus
            homologue = self.session.query(models.ArabidopsisHomologue).filter_by(a_thaliana_locus=locus).first()
            if not homologue:
                # Create new
                homologue = models.ArabidopsisHomologue(
                    a_thaliana_locus=locus,
                    a_thaliana_common_name=common_name,
                )
                self.session.add(homologue)
            
            # 3. Link them (only if not already linked)
            if homologue not in gene.arabidopsis_homologues:
                gene.arabidopsis_homologues.append(homologue)

            if i % 100 == 0:
                self.session.commit() 
                print(f"Processed {i} gene mappings.")   
            i += 1
        self.session.commit()
        print(f"Added {i} gene mappings to the database.")
        
    def create_or_update(self, model, values, lookup_fields):
        """
    Generic method to create or update any record in any model and return an instance of that record.

    Works even if the primary key is auto-generated by using a unique lookup field.

    Parameters:
        model: the model (or table) in which to perform the Create or Update task
        values: a list of dictionaries specifying the values the new record should contain
        lookup_field: the field (or unique column) used to identify whether a record exists (e.g., "gene_name", "sequence_name", etc.)
    """
        try:
            instance = None
            total = len(values)
            for idx, value in enumerate(values):
                #query the database using teh lookup field to see if the record exists

                filters = {field: value[field] for field in lookup_fields}
                query = self.session.query(model).filter_by(**filters)
                # Check if an instance exists
                instance = query.first()

                if instance is not None:
                    # print(f"Updating record with {value[lookup_field]}")
                    # Update the existing record
                    for key, val in value.items():
                        setattr(instance, key, val)
                else:
                    # print(f"Creating record with {value[lookup_field]}")
                    # Create a new record
                    instance = model(**value)
                    self.session.add(instance)
                print(f"Processed {idx+1}/{total} records")
            self.session.commit()
            return instance
        except SQLAlchemyError as e:
            self.session.rollback()
            print(e)
            raise e

    def batch_create_or_update(self, model, values, pk):
         
        """ 
        Generic method to create or update any record in any model and return an instance of that record.

            Also works for batch insertions or updates, in which case the last record of the batch job is returned.

            Parameters:
                model: the model (or table) in which to perform the Create or Update task
                values: a list of dictionaries specifying the values the new record should contain
                pk: the primary key of this table, as a string
        """
        batch_size = 1000
        instances = []

        for i, value in enumerate(values):

            instance = self.session.query(model).get(value[pk])
            
            if instance is not None:
                instance = self.session.merge(model(**value))

            else:
                instance = model(**value) 
                self.session.add(instance)

            instances.append(instance)

            # process the records in batches before committing
            if(i+1)% batch_size == 0:
                self.session.commit()
                instances = []

        if instances:
            self.session.commit()
        return instances[-1] if instances else None

    def add_gene_locus(self, model, values):
        """ 
        Update gene_location in the database by mapping it to Hit_acc.

        Parameters:
            model: the model (or table) to update
            df: a pandas DataFrame containing 'Hit_acc' and 'gene_location'
        """

        for i, value in enumerate(values):
            # Find the instance by matching Hit_acc
            instances = self.session.query(model).filter_by(Hit_ACC=value['Hit_ACC']).all()
            
            for instance in instances:
                if instance is not None:
                    instance.At_locus_id = value['At_locus_id']
                    instance.At_gene_name = value['At_gene_name']


        if instances:
            self.session.commit()

    def get_gene_expression_data(self, gene_names, experiment_name, filter_deg=DEGFilter.SHOW_ALL):
        """
        Fetches RNA-seq gene expression data for the specified genes and experiment, applying DEG filtering if required.

        Parameters:
            gene_names (list): List of gene names.
            experiment_name (str): Name of the experiment.
            filter_deg (DEGFilter): DEG filter option (Enum).

        Returns:
            pd.DataFrame: A DataFrame containing the filtered gene expression data.
        """
        
        query = (
            self.session.query(
                models.Gene_expressions.gene_id,
                models.Gene_expressions.normalised_expression,
                models.Gene_expressions.log2_expression,
                models.Gene_expressions.treatment,
                models.Gene_expressions.time,
                models.Gene_expressions.replicate,
                models.Gene.gene_name
            )
            .join(models.Gene, models.Gene_expressions.gene_id == models.Gene.id)
            .join(models.Experiments, models.Gene_expressions.experiment_id == models.Experiments.id)
            .filter(models.Experiments.experiment_name == experiment_name)
            .filter(models.Gene.gene_name.in_(gene_names))
        )

        # Apply DEG filtering based on the selected option
        if filter_deg == DEGFilter.SHOW_DEG:
            query = query.join(models.DifferentialExpression, models.DifferentialExpression.gene_id == models.Gene.id)
            query = query.filter(
                (models.DifferentialExpression.re_set.isnot(None)) | (models.DifferentialExpression.de_set.isnot(None))
            )
        elif filter_deg == DEGFilter.SHOW_UP:
            query = query.join(models.DifferentialExpression, models.DifferentialExpression.gene_id == models.Gene.id)
            query = query.filter(
                (models.DifferentialExpression.re_direction == "Up-regulated") | (models.DifferentialExpression.de_direction == "Up-regulated")
            )
        elif filter_deg == DEGFilter.SHOW_DOWN:
            query = query.join(models.DifferentialExpression, models.DifferentialExpression.gene_id == models.Gene.id)
            query = query.filter(
                (models.DifferentialExpression.re_direction == "Down-regulated") | (models.DifferentialExpression.de_direction == "Down-regulated")
            )

        # Execute query and return results as a DataFrame
        result = query.all()
        columns = ["gene_id", "normalised_expression", "log2_expression", "treatment", "time", "replicate","gene_name"]
        return pd.DataFrame(result, columns=columns)

    def get_species(self):
        """Retrieve all the species from the database.

        Returns:
            List[Species]: A list of Species objects.
        """
        results = self.session.query(models.Species).all()
        return results
    
    def get_gene_by_name(self, gene_name):
        query = self.session.query(models.Gene).filter_by(gene_name=gene_name).first()
        return query
    
    
    
    def get_gene_annotation_data(self, gene_list, query_type, species_name= "Any"):
        """Get annotation data associated with a list of Xerophyta gene names, GO terms or arabidopsis homologes (locus or common name).

        Args:
            gene_list (_type_): list of gene names, GO terms or arabidopsis homologes (locus or common name).
            query_type (_type_): The type of query to perform (e.g., "xerophyta_gene_name", "go_id", "A_thaliana_homologue").

        Returns:
            _type_: _description_
        """
     
        if isinstance(gene_list, str):
            gene_list = [gene_list]

        if species_name == "Any":
            species_id = None
        else:
            species_id = self.get_species_by_name(species_name).id

        results = []
        if query_type == "xerophyta_gene_name":
            results = self.get_gene_annotation_data_from_xerophyta_gene_names(gene_list, species_id)
        
        elif query_type == "a_thaliana_locus":
            loci_results = self.get_gene_annotation_data_from_a_thaliana_locus_homologue(gene_list, species_id)
            genes = [gene.gene_name for gene in loci_results]
            results = self.get_gene_annotation_data_from_xerophyta_gene_names(genes)

        elif query_type == "a_thaliana_common_name":
            common_name_results = self.get_gene_annotation_data_from_a_thaliana_common_name(gene_list, species_id)
            genes = [gene.gene_name for gene in common_name_results]
            results = self.get_gene_annotation_data_from_xerophyta_gene_names(genes)

        elif query_type == "go_id":
            go_term_results = self.get_gene_annotation_data_from_go_ids(gene_list, species_id)
            genes = [gene.gene_name for gene in go_term_results]
            results = self.get_gene_annotation_data_from_xerophyta_gene_names(genes, species_id)

        elif query_type == "go_name":
            go_term_results = self.get_gene_annotation_data_from_go_names(gene_list, species_id)
            genes = [gene.gene_name for gene in go_term_results]
            results = self.get_gene_annotation_data_from_xerophyta_gene_names(genes, species_id)


        elif query_type == "enzyme_code":
            enzyme_results = self.get_gene_annotation_data_from_enzyme_codes(gene_list, species_id)
            genes = [gene.gene_name for gene in enzyme_results]
            results = self.get_gene_annotation_data_from_xerophyta_gene_names(genes)

        elif query_type == "enzyme_name":
            enzyme_results = self.get_gene_annotation_data_from_enzyme_names(gene_list, species_id)
            genes = [gene.gene_name for gene in enzyme_results]
            results = self.get_gene_annotation_data_from_xerophyta_gene_names(genes)

        return results

    def get_gene_annotation_data_from_xerophyta_gene_names(self, gene_list, species_id=None):

        query = (
            self.session.query(models.Gene)
            .options(
                subqueryload(models.Gene.annotations)
                    .subqueryload(models.Annotation.go_ids),
                subqueryload(models.Gene.annotations)
                    .subqueryload(models.Annotation.enzyme_codes),
                subqueryload(models.Gene.annotations)
                    .subqueryload(models.Annotation.interpro_ids),
                subqueryload(models.Gene.arabidopsis_homologues)
            )
            .filter(models.Gene.gene_name.in_(gene_list))
        )

        if species_id is not None:
            query = query.filter(models.Gene.species_id == species_id)
        return query.all()     
    
    def get_gene_annotation_data_from_a_thaliana_locus_homologue(self, gene_list, species_id=None):
        
        query = (
            self.session.query(models.Gene)
            .join(models.Gene.arabidopsis_homologues)
            .filter(
                func.lower(models.ArabidopsisHomologue.a_thaliana_locus)
                .in_([locus.lower() for locus in gene_list]))
        )
        if species_id is not None:
            query = query.filter(models.Gene.species_id == species_id)
        return query.all()        
    
    def get_gene_annotation_data_from_a_thaliana_common_name(self, gene_list, species_id=None):
        """
            Search for genes based on partial matches of the Arabidopsis common names.
            
            Parameters:
                session (Session): SQLAlchemy session.
                search_terms (list of str): List of search terms to match against the common names.
            
            Returns:
                List of Gene objects that match any of the search criteria.
            """
        filters = [
                models.ArabidopsisHomologue.a_thaliana_common_name.ilike(f"%{term}%")
                for term in gene_list
                ]
    
        # Query Genes by joining with the homologues table and filtering with an OR condition
        query = (
            self.session.query(models.Gene)
                .join(models.Gene.arabidopsis_homologues)
                .filter(or_(*filters))
                .distinct()
        )
        if species_id is not None:
            query = query.filter(models.Gene.species_id == species_id)
        return query.all()    
                
    def get_gene_annotation_data_from_go_ids(self, go_list, species_id=None):
        # Normalize the GO terms provided by the user.
        normalized_go_list = [self.normalize_go_term(go) for go in go_list]

        # Use lower for case-insensitive matching
        query = (
            self.session.query(models.Gene)
            .join(models.Gene.annotations)
            .join(models.Annotation.go_ids)
            .filter(func.lower(models.GO.go_id).like(f"%{normalized_go_list[0].lower()}"))
            .distinct()
        )
        if species_id is not None:
            query = query.filter(models.Gene.species_id == species_id)
        return query.all()        
    
    def get_gene_annotation_data_from_go_names(self, go_name_list, species_id=None):
        filters = [
            models.GO.go_name.ilike(f"%{name}%") for name in go_name_list
        ]
        query = (
            self.session.query(models.Gene)
            .join(models.Gene.annotations)
            .join(models.Annotation.go_ids)
            .filter(or_(*filters))
            .distinct()
        )
        if species_id is not None:
            query = query.filter(models.Gene.species_id == species_id)
        return query.all()    
    
    def get_gene_annotation_data_from_enzyme_codes(self, enzyme_code_list, species_id=None):
        query = (
            self.session.query(models.Gene)
            .join(models.Gene.annotations)
            .join(models.Annotation.enzyme_codes)
            .filter(func.lower(models.EnzymeCode.enzyme_code)
            .in_([enzyme_code.lower() for enzyme_code in enzyme_code_list]))
            .distinct()
        )
        if species_id is not None:
            query = query.filter(models.Gene.species_id == species_id)
        return query.all()
    
    def get_gene_annotation_data_from_enzyme_names(self, enzyme_name_list, species_id=None):
        
        filters = [
            models.EnzymeCode.enzyme_name.ilike(f"%{term}%") 
            for term in enzyme_name_list 
            ]
        query = (
            self.session.query(models.Gene)
                .join(models.Gene.annotations)
                .join(models.Annotation.enzyme_codes)
                .filter(or_(*filters))
                .distinct()
        )
        if species_id is not None:
            query = query.filter(models.Gene.species_id == species_id)
        
        return query.all()

    def normalize_go_term(self, go_term):
        """
        Extracts the GO term from a string.
        For example:
        - "F:GO:0005524" -> "GO:0005524"
        - "GO:0005524" -> "GO:0005524"
        """
        match = re.search(r'(?:[A-Z]:)?(GO:\d+)', go_term, flags=re.IGNORECASE)
        if match:
            return match.group(1).upper()
        return go_term.upper()
      
    def flatten_gene_annotation_data(self, gene_annotations):
        data = []

        for gene in gene_annotations: 
            species = gene.species.name 
            gene_name=gene.gene_name
            coding_sequence = gene.coding_sequence
            
            a_thaliana_locus = None
            a_thaliana_common_name = None
            description= None
            e_value= None
            bit_score= None
            similarity= None
            alignment_length= None
            positives= None
            go_ids= None
            go_names= None
            enzyme_codes= None
            enzyme_names= None
            interpro_ids= None

            for homologue in gene.arabidopsis_homologues:
                a_thaliana_locus = homologue.a_thaliana_locus
                a_thaliana_common_name = homologue.a_thaliana_common_name
            
            for annotation in gene.annotations:
                description = annotation.description
                e_value = annotation.e_value
                bit_score = annotation.bit_score
                similarity = annotation.similarity
                alignment_length = annotation.alignment_length
                positives = annotation.positives
                
                go_ids = ", ".join([go.go_id for go in annotation.go_ids])
                go_names = ", ".join([go.go_name for go in annotation.go_ids])

                enzyme_codes = ", ".join([enzyme_codes.enzyme_code for enzyme_codes in annotation.enzyme_codes])
                enzyme_names = ", ".join([enzyme_codes.enzyme_name for enzyme_codes in annotation.enzyme_codes])
            
                interpro_ids = ", ".join([interpro.interpro_id for interpro in annotation.interpro_ids])

            data.append({
                "species": species,
                "gene_name": gene_name,
                "a_thaliana_locus": a_thaliana_locus,
                "a_thaliana_common_name": a_thaliana_common_name,
                "description": description,
                "coding_sequence": coding_sequence,
                "e_value": e_value,
                "bit_score": bit_score,
                "similarity": similarity,
                "alignment_length": alignment_length,
                "positives": positives,
                "go_ids": go_ids,
                "go_names": go_names,
                "enzyme_codes": enzyme_codes,
                "enzyme_names": enzyme_names,
                "interpro_ids": interpro_ids
            })
               
        return data
       
    
    def get_species_by_name(self, species_name):  
        """Retrieve a species object by its name.

        Args:
            species_name (str): The name of the species.

        Returns:
            Species: A Species object
        """
        query = self.session.query(models.Species).filter_by(name=species_name).first()
        return query

    def get_experiments(self):
        results = self.session.query(models.Experiments).all()
        
        return results
    
    def get_experiment_by_name(self, experiment_name):
        """Get an experiment by its name.

        Args:
            experiment_name (str): The name of the experiment.

        Returns:
            Experiments: An Experiments object.
        """
        experiment = self.session.query(models.Experiments).filter_by(experiment_name=experiment_name).first()
        return experiment

    def get_experiments_by_species(self, species_name):
        """
        Retrieve all experiments associated with a given species name.

        Parameters:
            species_name (str): The name of the species.

        Returns:
            List[Experiments]: A list of Experiment objects associated with the species.
        """
        # Query experiments associated with the given species
        results = (
            self.session.query(models.Experiments)
            .join(models.Gene_expressions, models.Experiments.id == models.Gene_expressions.experiment_id)
            .join(models.Species, models.Gene_expressions.species_id == models.Species.id)
            .filter(models.Species.name == species_name)
            .distinct()  # To avoid duplicates
            .all()
        )
        return results

    def link_experiment_to_species(self, experiment_name, species_name):
        
        species = self.get_species_by_name(species_name)
    
        if not species:
            print(f"Species '{species_name}' does not exist in the database.")
            return

        experiment = self.get_experiment_by_name(experiment_name)
        if not experiment:
            print(f"Experiment '{experiment_name}' does not exist in the database.")
            return

        # Step 3: Link the experiment to the species
        if experiment.species is None:
            experiment.species = species
        else:
            print(f"Experiment '{experiment_name}' is already linked to a species '{experiment.species.name}'.")
            return

        # Step 4: Commit the changes
        print(f"Experiment '{experiment_name}' is now linked to species '{species_name}'.")
        self.session.commit()

    def check_if_gene_in_database(self, gene_list):
        """
        Check if a gene is in the database.

        Parameters:
            gene_list (list): A list of gene names to check.

        Returns:
            List[str]: A boolean list if gene is in the database.
        """
        in_db = []
        for gene in gene_list:
            query = self.session.query(models.Gene).filter(models.Gene.gene_name == gene).first()
            if query:
                in_db.append(True)
            else:
                in_db.append(False)
        return in_db
    
    def check_if_go_term_in_database(self, go_terms):
        """
        Check if a GO term is in the database.

        Parameters:
            go_terms (list): A list of GO terms to check.

        Returns:
            List[str]: A boolean list if GO term is in the database.
        """
        in_db = []
        for term in go_terms:
            query = self.session.query(models.GO).filter(
                or_
                (models.GO.go_id.in_(term),models.GO.go_name.in_(term))
                ).first()
       
            if query:
                in_db.append(True)
            else:
                in_db.append(False)
        return in_db


    def get_genes_by_go_term_or_description(self, go_inputs, species_name= None):
        """
        Query genes associated with a list of GO names or GO IDs.

        Parameters:
            go_inputs (list of str): GO names or GO IDs to query.

        Returns:
            List[Gene]: List of Gene objects associated with the GO terms.
        """
        # Preprocess each GO term to handle missing prefixes
        processed_inputs = []
        for term in go_inputs:
            if ":" not in term:
                # Generate possible matches by prepending the valid prefixes
                processed_inputs.extend([f"P:{term}", f"F:{term}", f"C:{term}"])
            else:
                # Directly add the user-provided term
                processed_inputs.append(term)

        # Build query
        query = (
            self.session.query(models.Gene)
            .join(models.Annotation, models.Annotation.gene_id == models.Gene.id)
            .join(models.annotations_go, models.annotations_go.c.annotation_id ==models.Annotation.id)
            .join(models.GO, models.GO.id == models.annotations_go.c.go_id)
            .filter(
                or_(
                    models.GO.go_id.in_(processed_inputs),  # Match any of the possible GO IDs
                    *[models.GO.go_name.ilike(f"%{term}%") for term in go_inputs]  # Match GO names (case-insensitive)
                )
            )
        )
        # Add an optional species filter
        if species_name:
            query = query.join(models.Species, models.Gene.species_id == models.Species.id).filter(
            models.Species.name.ilike(f"%{species_name}%")
        )

        results = query.all()
        return results
    
    
   